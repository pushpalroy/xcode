package com.example.xcode.rx

import io.reactivex.Observable
import io.reactivex.ObservableSource
import io.reactivex.Observer
import io.reactivex.disposables.Disposable

fun main() {
  //opOnErrorResumeNext()
  //opOnExceptionResumeNext()
  //opDoOnError()
  //opOnErrorReturnItem()
  //opOnErrorReturn()
  opRetry()
}

/**
 * Handles the throwable generated by Kotlin code.
 * It won't be moving to onError directly and the error would be handled
 * in onErrorResumeNext and we can perform the rest actions in that
 */
private fun opOnErrorResumeNext() {
  Observable.just(1, 2, 3, 4)
      .map { x ->
        if (x == 3) {
          throw NullPointerException("Its a NPE")
        }
        x * 10
      }
      .onErrorResumeNext { t: Throwable ->
        return@onErrorResumeNext ObservableSource {
          println("onErrorResumeNext ${t.message}")
        }
      }
      .subscribe(object : Observer<Int> {
        override fun onSubscribe(d: Disposable) {
          println("onSubscribe called")
        }

        override fun onNext(t: Int) {
          println("onNext called: $t")
        }

        override fun onError(e: Throwable) {
          println("onError called: ${e.message}")
        }

        override fun onComplete() {
          println("onComplete called")
        }
      })
}

/**
 * It won't be moving to onError directly and the exception would be handled
 * in onExceptionResumeNext and we can perform the rest actions in that
 */
private fun opOnExceptionResumeNext() {
  Observable.just(1, 2, 3, 4)
      .doOnNext {
        if (it == 3) {
          throw (RuntimeException("Exception on 3"))
        }
      }
      .onExceptionResumeNext {
        println("onExceptionResumeNext: $it")
      }
      .subscribe(object : Observer<Int> {
        override fun onSubscribe(d: Disposable) {
          println("onSubscribe called")
        }

        override fun onNext(t: Int) {
          println("onNext called: $t")
        }

        override fun onError(e: Throwable) {
          println("onError called: ${e.message}")
        }

        override fun onComplete() {
          println("onComplete called")
        }
      })
}

/**
 * Side-effect operators are the ones which gets called even before the
 * main subscriber methods being called like onNext, onError
 */
private fun opDoOnError() {
  Observable.just(1, 2, 3, 4)
      .doOnNext {
        if (it == 3) {
          throw (RuntimeException("Exception on 3"))
        }
      }
      .doOnError {
        println("doOnError: ${it.message}")
      }
      .subscribe(object : Observer<Int> {
        override fun onSubscribe(d: Disposable) {
          println("onSubscribe called")
        }

        override fun onNext(t: Int) {
          println("onNext called: $t")
        }

        override fun onError(e: Throwable) {
          println("onError called: ${e.message}")
        }

        override fun onComplete() {
          println("onComplete called")
        }
      })
}

/**
 * We return an item whenever any exception or error occurred followed by onComplete
 *
 * Note: The positioning of onErrorReturnItem matters as if we call it above doOnNext,
 * it wouldn't be called after the Observable Exception and then onError will be called directly.
 */
private fun opOnErrorReturnItem() {
  Observable.just(1, 2, 3, 4)
      .doOnNext {
        if (it == 3) {
          throw (RuntimeException("Exception on 3"))
        }
      }
      .onErrorReturnItem(30)
      .subscribe(object : Observer<Int> {
        override fun onSubscribe(d: Disposable) {
          println("onSubscribe called")
        }

        override fun onNext(t: Int) {
          println("onNext called: $t")
        }

        override fun onError(e: Throwable) {
          println("onError called: ${e.message}")
        }

        override fun onComplete() {
          println("onComplete called")
        }
      })
}

/**
 * We return an item whenever any exception or error occurred followed by onComplete
 * We sometimes need to produce the default item when an error or exception
 * So onErrorReturn provides us a throwable and a lambda to return
 *
 * Note: onErrorReturn replaces onError with a single onNext(value) followed by onCompleted()
 * If we don't pass a value in onErrorReturn operator, we will get a default value from the operator
 */
private fun opOnErrorReturn() {
  Observable.just(1, 2, 3, 4)
      .doOnNext {
        if (it == 3) {
          throw (RuntimeException("Exception on 3"))
        }
      }
      .onErrorReturn { t: Throwable ->
        println("onErrorReturn: ${t.message}")
        30
      }
      .subscribe(object : Observer<Int> {
        override fun onSubscribe(d: Disposable) {
          println("onSubscribe called")
        }

        override fun onNext(t: Int) {
          println("onNext called: $t")
        }

        override fun onError(e: Throwable) {
          println("onError called: ${e.message}")
        }

        override fun onComplete() {
          println("onComplete called")
        }
      })
}

/**
 * We re-subscribe the observable and give it a chance to get called again.
 *
 * Note : If we don't pass 6, it will keep on retrying unless it is successful
 * In our case it will make retry itself infinitely as we won't be successful
 */
private fun opRetry() {
  Observable.just(1, 2, 3, 4)
      .doOnNext {
        if (it == 3) {
          throw (RuntimeException("Exception on 3"))
        }
      }
      .retry(6)
      .subscribe(object : Observer<Int> {
        override fun onSubscribe(d: Disposable) {
          println("onSubscribe called")
        }

        override fun onNext(t: Int) {
          println("onNext called: $t")
        }

        override fun onError(e: Throwable) {
          println("onError called: ${e.message}")
        }

        override fun onComplete() {
          println("onComplete called")
        }
      })
}